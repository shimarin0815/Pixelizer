<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pet/Item Pixelizer – 丸ステッカー生成</title>
  <meta name="description" content="画像を8bit風にして丸ステッカーPNGを即出力するシングルページアプリ" />
  <style>
    /* --- Reset (lightweight) --- */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Noto Sans JP", sans-serif; color: #0f172a; background: radial-gradient(1200px 600px at 10% -10%, #eef6ff 0%, #ffffff 40%), radial-gradient(1200px 600px at 110% 110%, #f4ecff 0%, #ffffff 40%); }
    :root {
      --card-bg: rgba(255,255,255,0.7);
      --card-bd: rgba(15,23,42,0.06);
      --muted: #475569;
      --accent: #6759ff;
      --accent-2: #22c55e;
      --shadow: 0 10px 30px rgba(2,6,23,0.08), 0 6px 12px rgba(2,6,23,0.04);
      --radius: 18px;
    }

    header { position: sticky; top: 0; z-index: 2; backdrop-filter: saturate(1.2) blur(10px); background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0.45)); border-bottom: 1px solid var(--card-bd); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px 20px; }
    .brand { display:flex; align-items:center; gap:12px; }
    .logo { width: 36px; height: 36px; border-radius: 50%; background: conic-gradient(from 0deg, #6759ff, #7c3aed, #22d3ee, #22c55e, #f59e0b, #ef4444, #6759ff); box-shadow: inset 0 0 0 4px #fff; }
    h1 { font-size: clamp(18px, 2.4vw, 24px); margin: 0; letter-spacing: 0.3px; }
    .sub { color: var(--muted); font-size: 13px; }

    main { padding: 26px 20px 40px; }
    .grid { display: grid; grid-template-columns: 1.05fr 1fr; gap: 22px; align-items: start; }
    @media (max-width: 960px){ .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card-bg); border: 1px solid var(--card-bd); border-radius: var(--radius); box-shadow: var(--shadow); }
    .card h2 { margin: 0; padding: 16px 18px 10px; font-size: 18px; }
    .card .content { padding: 14px 18px 18px; }

    /* Upload zone */
    .drop { position: relative; border: 1px dashed #cbd5e1; border-radius: 14px; padding: 18px; background: linear-gradient(180deg, rgba(255,255,255,.9), rgba(255,255,255,.6)); display:flex; gap:16px; align-items:center; cursor: pointer; transition: border-color .2s, box-shadow .2s; }
    .drop:hover { border-color: #94a3b8; box-shadow: 0 6px 16px rgba(2,6,23,0.06); }
    .drop input { display:none; }
    .drop .icon { width: 44px; height: 44px; display:grid; place-items:center; border-radius: 12px; background: #f1f5f9; }
    .drop .hint { font-size: 14px; color: var(--muted); }

    /* Controls */
    .control { margin-top: 14px; }
    .control label { display:flex; justify-content:space-between; align-items:end; font-size: 13px; color: #0f172a; margin-bottom: 6px; }
    .value { color: var(--muted); font-variant-numeric: tabular-nums; }
    input[type="range"] { width: 100%; appearance: none; height: 28px; background: transparent; }
    input[type="range"]::-webkit-slider-runnable-track { height: 6px; background: linear-gradient(90deg, var(--accent), #60a5fa); border-radius: 999px; }
    input[type="range"]::-moz-range-track { height: 6px; background: linear-gradient(90deg, var(--accent), #60a5fa); border-radius: 999px; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #fff; border: 1px solid #cbd5e1; box-shadow: 0 2px 8px rgba(2,6,23,0.2); margin-top: -6px; }
    input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border: none; border-radius: 50%; background: #fff; box-shadow: 0 2px 8px rgba(2,6,23,0.2); }

    .row { display:flex; gap: 12px; align-items: center; }
    .row > * { flex: 1; }
    .switch { display:flex; align-items:center; gap:8px; font-size: 13px; color: var(--muted); }
    .switch input[type="checkbox"] { appearance: none; width: 40px; height: 22px; border-radius: 999px; background: #e2e8f0; position: relative; outline: none; transition: background .2s; }
    .switch input[type="checkbox"]::after { content: ""; position: absolute; top: 3px; left: 3px; width: 16px; height: 16px; background: #fff; border-radius: 50%; box-shadow: 0 1px 5px rgba(0,0,0,0.2); transition: transform .2s; }
    .switch input[type="checkbox"]:checked { background: var(--accent); }
    .switch input[type="checkbox"]:checked::after { transform: translateX(18px); }

    .btns { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 16px; }
    button, .btn { appearance:none; border: 1px solid transparent; border-radius: 12px; padding: 10px 14px; font-weight: 600; cursor: pointer; box-shadow: var(--shadow); background: #111827; color: #fff; }
    .btn.secondary { background: #fff; color: #0f172a; border-color: #cbd5e1; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    /* Preview */
    .preview-wrap { display:grid; gap: 14px; }
    .stage { position: relative; aspect-ratio: 1 / 1; width: 100%; max-width: 480px; margin: 0 auto; border-radius: 20px; border: 1px solid var(--card-bd); box-shadow: var(--shadow); overflow: hidden; background-image: linear-gradient(45deg, #e2e8f0 25%, transparent 25%), linear-gradient(-45deg, #e2e8f0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #e2e8f0 75%), linear-gradient(-45deg, transparent 75%, #e2e8f0 75%); background-size: 22px 22px; background-position: 0 0, 0 11px, 11px -11px, -11px 0px; background-color: #f8fafc; }
    canvas#preview { display:block; width: 100%; height: 100%; image-rendering: pixelated; }
    .stage .overlay { position: absolute; inset: 0; display: grid; place-items: center; color: var(--muted); text-align:center; font-size: 14px; padding: 16px; pointer-events: none; }
    .pill { display:inline-flex; align-items:center; gap:8px; background: rgba(255,255,255,.8); border: 1px solid var(--card-bd); padding: 8px 12px; border-radius: 999px; box-shadow: var(--shadow); }

    footer { text-align:center; color: var(--muted); font-size: 12px; padding: 26px 10px 40px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; border: 1px solid #cbd5e1; background: #fff; padding: 1px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="brand" aria-label="アプリの見出し">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Pet/Item Pixelizer</h1>
          <div class="sub">画像を8bit風にして丸ステッカーPNGを即出力</div>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="wrap grid">
      <!-- Left: Controls -->
      <section class="card" aria-label="コントロール">
        <h2>1) 画像をアップロード</h2>
        <div class="content">
          <label class="drop" id="drop">
            <input id="file" type="file" accept="image/*" />
            <div class="icon" aria-hidden="true">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 16V4m0 0l-4 4m4-4l4 4" stroke="#0f172a" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M20 16.5A4.5 4.5 0 0015.5 12H14a6 6 0 10-11.995.2A4 4 0 004 20h12.5a3.5 3.5 0 003.5-3.5z" stroke="#0f172a" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <div>
              <div><strong>ドラッグ＆ドロップ</strong> または クリックで選択</div>
              <div class="hint">スマホの写真もOK。ペット・推し・アイテム写真など。</div>
            </div>
          </label>

          <div class="control">
            <label for="diameter">出力サイズ（直径）<span class="value"><span id="diameterVal">512</span> px</span></label>
            <input id="diameter" type="range" min="256" max="2048" step="64" value="512" />
          </div>

          <div class="control">
            <label for="dot">ドットサイズ（ピクセルの大きさ）<span class="value"><span id="dotVal">8</span> px</span></label>
            <input id="dot" type="range" min="2" max="64" step="1" value="8" />
          </div>

          <div class="row control">
            <div>
              <label for="border">フチの太さ<span class="value"><span id="borderVal">6</span> px</span></label>
              <input id="border" type="range" min="0" max="40" step="1" value="6" />
            </div>
            <div>
              <label for="borderColor">フチ色</label>
              <input id="borderColor" type="color" value="#ffffff" style="width:100%; height: 36px; border-radius: 10px; border:1px solid #cbd5e1; background:#fff;" />
            </div>
          </div>

          <div class="row control">
            <label class="switch" title="背景を透明にするとシールの周りが透明のPNGになります">
              <input id="bgTransparent" type="checkbox" checked /> 透明背景
            </label>
            <input id="bgColor" type="color" value="#ffffff" style="width:100%; height: 36px; border-radius: 10px; border:1px solid #cbd5e1; background:#fff;" />
          </div>

          <div class="btns">
            <button id="saveBtn" disabled>
              <span aria-hidden="true">💾</span> PNGで保存
            </button>
            <button id="resetBtn" class="btn secondary">リセット</button>
          </div>
        </div>
      </section>

      <!-- Right: Preview -->
      <section class="card" aria-label="プレビュー">
        <h2>2) プレビュー＆保存</h2>
        <div class="content preview-wrap">
          <div class="stage" id="stage">
            <canvas id="preview" width="600" height="600" aria-label="ステッカープレビュー"></canvas>
            <div class="overlay" id="overlay">
              <span class="pill">画像を読み込むとここに表示されます</span>
            </div>
          </div>
          <div class="row" style="justify-content:center; color: var(--muted); font-size: 12px;">
            <div>ヒント: 貼りたい場所に合わせて <span class="kbd">出力サイズ</span> と <span class="kbd">ドットサイズ</span> を調整</div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer>
    <div>すべてブラウザ内で処理され、画像はサーバーに送られません。</div>
  </footer>

  <script>
    // ====== State ======
    const els = {
      file: document.getElementById('file'),
      drop: document.getElementById('drop'),
      diameter: document.getElementById('diameter'),
      diameterVal: document.getElementById('diameterVal'),
      dot: document.getElementById('dot'),
      dotVal: document.getElementById('dotVal'),
      border: document.getElementById('border'),
      borderVal: document.getElementById('borderVal'),
      borderColor: document.getElementById('borderColor'),
      bgTransparent: document.getElementById('bgTransparent'),
      bgColor: document.getElementById('bgColor'),
      preview: document.getElementById('preview'),
      stage: document.getElementById('stage'),
      overlay: document.getElementById('overlay'),
      saveBtn: document.getElementById('saveBtn'),
      resetBtn: document.getElementById('resetBtn')
    };

    let img = null; // HTMLImageElement
    let imgName = 'pixel-sticker';

    // Utility: central square crop rect
    function getCenterSquareRect(w, h){
      const size = Math.min(w, h);
      const sx = (w - size) / 2;
      const sy = (h - size) / 2;
      return {sx, sy, sSize: size};
    }

    function setDisabled(disabled){
      els.saveBtn.disabled = disabled;
    }

    function updateLabels(){
      els.diameterVal.textContent = els.diameter.value;
      els.dotVal.textContent = els.dot.value;
      els.borderVal.textContent = els.border.value;
      els.bgColor.disabled = els.bgTransparent.checked;
    }

    // Draw the preview using export parameters, scaled to preview canvas size
    function drawPreview(){
      const cv = els.preview;
      const ctx = cv.getContext('2d');
      const stage = els.stage.getBoundingClientRect();
      const size = Math.min(stage.width, stage.height);
      cv.width = cv.height = Math.round(size * window.devicePixelRatio);
      cv.style.width = cv.style.height = `${Math.round(size)}px`;

      ctx.clearRect(0,0,cv.width, cv.height);
      if(!img){ return; }

      const D = Number(els.diameter.value);
      const dot = Math.max(1, Number(els.dot.value));
      const small = Math.max(1, Math.floor(D / dot));
      const border = Number(els.border.value);
      const borderColor = els.borderColor.value;
      const bgTransparent = els.bgTransparent.checked;
      const bgColor = els.bgColor.value;

      // Step1: draw source into small square (central crop, cover)
      const smallC = document.createElement('canvas');
      smallC.width = smallC.height = small;
      const sctx = smallC.getContext('2d');
      sctx.imageSmoothingEnabled = false;
      const {sx, sy, sSize} = getCenterSquareRect(img.naturalWidth, img.naturalHeight);
      sctx.drawImage(img, sx, sy, sSize, sSize, 0, 0, small, small);

      // Step2: upscale to preview size with nearest-neighbor
      const P = cv.width; // device pixel size
      ctx.save();
      // circle clip (account for border inside)
      const radius = P/2 - (border>0 ? (border * (P/D))/2 : 0);
      ctx.beginPath();
      ctx.arc(P/2, P/2, radius, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();

      if(!bgTransparent){
        ctx.fillStyle = bgColor;
        ctx.fillRect(0,0,P,P);
      }

      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(smallC, 0, 0, small, small, 0, 0, P, P);
      ctx.restore();

      // border (draw after)
      if(border > 0){
        ctx.beginPath();
        ctx.arc(P/2, P/2, P/2 - (border * (P/D))/2, 0, Math.PI*2);
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = border * (P/D);
        ctx.stroke();
      }
    }

    function generateExportCanvas(){
      const D = Number(els.diameter.value);
      const dot = Math.max(1, Number(els.dot.value));
      const small = Math.max(1, Math.floor(D / dot));
      const border = Number(els.border.value);
      const borderColor = els.borderColor.value;
      const bgTransparent = els.bgTransparent.checked;
      const bgColor = els.bgColor.value;

      const out = document.createElement('canvas');
      out.width = out.height = D;
      const ctx = out.getContext('2d');

      // small
      const smallC = document.createElement('canvas');
      smallC.width = smallC.height = small;
      const sctx = smallC.getContext('2d');
      sctx.imageSmoothingEnabled = false;
      const {sx, sy, sSize} = getCenterSquareRect(img.naturalWidth, img.naturalHeight);
      sctx.drawImage(img, sx, sy, sSize, sSize, 0, 0, small, small);

      // clip circle
      ctx.save();
      const radius = D/2 - (border>0 ? border/2 : 0);
      ctx.beginPath();
      ctx.arc(D/2, D/2, radius, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();

      if(!bgTransparent){
        ctx.fillStyle = bgColor;
        ctx.fillRect(0,0,D,D);
      }

      // upscale with nearest-neighbor
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(smallC, 0, 0, small, small, 0, 0, D, D);
      ctx.restore();

      // border
      if(border > 0){
        ctx.beginPath();
        ctx.arc(D/2, D/2, D/2 - border/2, 0, Math.PI*2);
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = border;
        ctx.stroke();
      }

      return out;
    }

    // ====== File Handling ======
    function loadFile(file){
      if(!file) return;
      imgName = (file.name ? file.name.replace(/\.[^.]+$/, '') : 'pixel-sticker') + '-8bit';
      const reader = new FileReader();
      reader.onload = () => {
        const image = new Image();
        image.onload = () => {
          img = image;
          els.overlay.style.display = 'none';
          setDisabled(false);
          drawPreview();
        };
        image.onerror = () => alert('画像の読み込みに失敗しました。別のファイルでお試しください。');
        image.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    // drag & drop
    els.drop.addEventListener('click', () => els.file.click());
    els.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); els.drop.style.borderColor = '#94a3b8'; });
    els.drop.addEventListener('dragleave', ()=>{ els.drop.style.borderColor = '#cbd5e1'; });
    els.drop.addEventListener('drop', (e)=>{ e.preventDefault(); els.drop.style.borderColor = '#cbd5e1'; const f = e.dataTransfer.files?.[0]; if(f) loadFile(f); });
    els.file.addEventListener('change', (e)=> loadFile(e.target.files?.[0]));

    // paste from clipboard
    window.addEventListener('paste', (e)=>{
      const item = [...(e.clipboardData?.items||[])].find(it=>it.type.startsWith('image/'));
      if(item){ loadFile(item.getAsFile()); }
    });

    // ====== Controls ======
    for(const id of ['diameter','dot','border']){
      els[id].addEventListener('input', ()=>{ updateLabels(); drawPreview(); });
    }
    els.borderColor.addEventListener('input', ()=> drawPreview());
    els.bgTransparent.addEventListener('change', ()=>{ updateLabels(); drawPreview(); });
    els.bgColor.addEventListener('input', ()=> drawPreview());

    els.saveBtn.addEventListener('click', async ()=>{
      if(!img) return;
      const out = generateExportCanvas();
      if(out.toBlob){
        out.toBlob((blob)=>{
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${imgName}.png`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }, 'image/png');
      } else {
        const a = document.createElement('a');
        a.href = out.toDataURL('image/png');
        a.download = `${imgName}.png`;
        a.click();
      }
    });

    els.resetBtn.addEventListener('click', ()=>{
      img = null;
      els.file.value = '';
      els.diameter.value = 512;
      els.dot.value = 8;
      els.border.value = 6;
      els.borderColor.value = '#ffffff';
      els.bgTransparent.checked = true;
      els.bgColor.value = '#ffffff';
      updateLabels();
      setDisabled(true);
      els.overlay.style.display = '';
      const ctx = els.preview.getContext('2d');
      ctx.clearRect(0,0,els.preview.width, els.preview.height);
    });

    // layout/resize
    const ro = new ResizeObserver(()=> drawPreview());
    ro.observe(els.stage);

    updateLabels();
  </script>
</body>
</html>
